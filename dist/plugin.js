async function h(i){if(i.valuesByMode&&typeof i.valuesByMode=="object"){const a=Object.keys(i.valuesByMode);for(const t of a){const e=i.valuesByMode[t];if(e&&typeof e=="object"&&"type"in e&&e.type==="VARIABLE_ALIAS"&&e.id){const r=await figma.variables.getVariableByIdAsync(e.id);if(r){const n=await k(r);if(n!==void 0)return n}}else if(i.resolvedType==="COLOR"&&typeof e=="object"&&"r"in e){const r={r:e.r,g:e.g,b:e.b};return"a"in e&&(r.a=e.a),r}else if(i.resolvedType==="FLOAT"&&typeof e=="number")return e}}return null}async function k(i){return h(i)}function w(i,a,t){return new Promise((e,r)=>{const s=i.flatMap(y=>y.variables).filter(y=>y.scopes&&y.scopes.length>0);let p=0;const l=[];function u(){const y=s.slice(p,p+a);Promise.all(y.map(async f=>{const c=await h(f);l.push({alias:f.name||"No alias",id:f.id,value:c,type:f.resolvedType==="COLOR"?"color":"number",isRemote:f.remote,libraryName:i.find(b=>b.variables.includes(f)).libraryName,scopes:f.scopes||[],collectionName:i.find(b=>b.variables.includes(f)).collectionName})})).then(()=>{p+=a,p<s.length?setTimeout(u,0):(t(l),e())}).catch(r)}u()})}async function B(){try{const i=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const a of i){const t=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(a.key);for(const e of t)(e.resolvedType==="COLOR"||e.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(e.key)}figma.notify("âœ… Variables imported correctly.")}catch(i){console.error("Error when importing remote variables:",i),figma.notify("ðŸš¨ Error when importing remote variables.")}}async function L(){try{figma.ui.postMessage({type:"loading-start"}),await B();const i=await figma.variables.getLocalVariableCollectionsAsync(),a=[];for(const n of i){const s=[];for(const p of n.variableIds){const l=await figma.variables.getVariableByIdAsync(p);((l==null?void 0:l.resolvedType)==="COLOR"||(l==null?void 0:l.resolvedType)==="FLOAT")&&s.push(l)}a.push({variables:s,libraryName:"Local",collectionName:n.name})}const t=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),e=[];for(const n of t){const s=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(n.key),p={variables:[],libraryName:n.libraryName,collectionName:n.name};for(const l of s)if(l.resolvedType==="COLOR"||l.resolvedType==="FLOAT"){const u=await figma.variables.importVariableByKeyAsync(l.key);p.variables.push(u)}e.push(p)}const r=[...a,...e];await w(r,50,async n=>{figma.ui.postMessage({type:"all-data",variables:n})})}catch(i){console.error("Error loading all variables :",i),figma.notify("ðŸš¨ Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const A=async(i,a,t)=>{const{scopes:e}=i;if(e.includes("ALL_SCOPES"))return!0;if(i.resolvedType==="COLOR"){if(a==="fill"&&"fills"in t)return e.includes("ALL_FILLS")||e.includes("FRAME_FILL")&&t.type==="FRAME"||e.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(t.type)?!0:e.includes("TEXT_FILL")&&t.type==="TEXT";if(a==="stroke"&&"strokes"in t)return e.includes("STROKE_COLOR")}else if(i.resolvedType==="FLOAT"){if(a==="spaceBetween"&&t.type==="FRAME")return e.includes("GAP");if(a==="borderRadius"&&"cornerRadius"in t)return e.includes("CORNER_RADIUS");if(a.includes("padding")&&t.type==="FRAME")return t.layoutMode==="NONE"?!1:e.includes("GAP");if(a==="strokeWidth"&&"strokeWeight"in t)return e.includes("STROKE_FLOAT")}return!1};async function O(i,a,t){if(i.length>0&&a)try{let e=!1;for(const r of i)if(await A(a,t,r)){if(t==="fill"&&"fills"in r)if(e=!0,Array.isArray(r.fills)&&r.fills.length>0){const s=[...r.fills];s[0]=figma.variables.setBoundVariableForPaint(s[0],"color",a),r.fills=s}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",a)];else if(t==="stroke"&&"strokes"in r)if(e=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const s=[...r.strokes];s[0]=figma.variables.setBoundVariableForPaint(s[0],"color",a),r.strokes=s}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",a)]}e?figma.notify("âœ… Variable applied correctly."):figma.notify("ðŸš« Scope limitation.")}catch(e){console.error("Error when applying the variable:",e),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}const R=(i,a)=>{if("layoutMode"in i){if(i.layoutMode==="NONE"){let t="";switch(a){case"spaceBetween":t="spacing";break;case"paddingVertical":case"paddingHorizontal":case"paddingGeneral":t="padding";break;default:t="this property"}return{hasAutoLayout:!1,message:`ðŸš¨ Auto Layout required for ${t}. Please enable Auto Layout on this frame manually.`}}return{hasAutoLayout:!0,message:""}}return{hasAutoLayout:!1,message:"ðŸš¨ Node must be a frame to apply spacing properties."}},m=(i,a,t)=>{t==="vertical"?(i.setBoundVariable("paddingTop",a),i.setBoundVariable("paddingBottom",a)):t==="horizontal"?(i.setBoundVariable("paddingLeft",a),i.setBoundVariable("paddingRight",a)):t==="general"&&(i.setBoundVariable("paddingTop",a),i.setBoundVariable("paddingBottom",a),i.setBoundVariable("paddingLeft",a),i.setBoundVariable("paddingRight",a))},v=(i,a)=>{"strokes"in i&&(Array.isArray(i.strokes)&&i.strokes.length>0&&i.strokes.some(e=>e.visible!==!1)||(i.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),i.setBoundVariable("strokeWeight",a),i.setBoundVariable("strokeTopWeight",a),i.setBoundVariable("strokeRightWeight",a),i.setBoundVariable("strokeBottomWeight",a),i.setBoundVariable("strokeLeftWeight",a)},C=(i,a)=>{i.setBoundVariable("topLeftRadius",a),i.setBoundVariable("topRightRadius",a),i.setBoundVariable("bottomLeftRadius",a),i.setBoundVariable("bottomRightRadius",a)},E=(i,a)=>{const t=i.scopes;return t.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:a==="spaceBetween"&&t.includes("GAP")?{isCompatible:!0,warning:""}:a.includes("padding")&&t.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},N=async(i,a,t)=>{var r,n,s,p,l,u,y,f;let e="";for(const c of i){if(!await A(a,t,c)){e="ðŸš« Scope limitation.";continue}if(!("setBoundVariable"in c)){e="ðŸš¨ Node does not support variable binding.";continue}if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(t)){const{hasAutoLayout:d,message:o}=R(c,t);if(!d){figma.notify(o);return}e+=o}const{isCompatible:V,warning:g}=E(a,t);switch(V||(e+=g),t){case"spaceBetween":c.setBoundVariable("itemSpacing",a),e="âœ… Spacing variable applied correctly.";break;case"borderRadius":C(c,a),e="âœ… Border radius variable applied correctly.";break;case"paddingVertical":if(c.type==="FRAME"){const d=c;if(d.layoutMode==="NONE"){e="ðŸš¨ Auto Layout required for padding. Please enable Auto Layout on this frame manually.";break}try{m(d,a,"vertical");const o=d.boundVariables;((r=o==null?void 0:o.paddingTop)==null?void 0:r.id)===a.id||((n=o==null?void 0:o.paddingBottom)==null?void 0:n.id)===a.id?(e="âœ… Vertical padding variable applied correctly.",g&&(e+=`
ðŸ’¡ `+g)):e="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){e="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(c.type==="FRAME"){const d=c;if(d.layoutMode==="NONE"){e="ðŸš¨ Auto Layout required for padding. Please enable Auto Layout on this frame manually.";break}try{m(d,a,"horizontal");const o=d.boundVariables;((s=o==null?void 0:o.paddingLeft)==null?void 0:s.id)===a.id||((p=o==null?void 0:o.paddingRight)==null?void 0:p.id)===a.id?(e="âœ… Horizontal padding variable applied correctly.",g&&(e+=`
ðŸ’¡ `+g)):e="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){e="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(c.type==="FRAME"){const d=c;if(d.layoutMode==="NONE"){e="ðŸš¨ Auto Layout required for padding. Please enable Auto Layout on this frame manually.";break}try{m(d,a,"general");const o=d.boundVariables;((l=o==null?void 0:o.paddingTop)==null?void 0:l.id)===a.id||((u=o==null?void 0:o.paddingBottom)==null?void 0:u.id)===a.id||((y=o==null?void 0:o.paddingLeft)==null?void 0:y.id)===a.id||((f=o==null?void 0:o.paddingRight)==null?void 0:f.id)===a.id?(e="âœ… Padding variable applied to all sides correctly.",g&&(e+=`
ðŸ’¡ `+g)):e="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){e="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in c&&(v(c,a),e="âœ… Stroke variable applied with dark border.");break;default:e="ðŸš¨ Unknown action."}}figma.notify(e)};figma.showUI(__html__,{width:240,height:664});async function T(i,a){const t=figma.currentPage.selection;if(t.length>0&&i)try{const e=await figma.variables.getVariableByIdAsync(i);if(!e){figma.notify("Error: Could not obtain the variable.");return}await O(t,e,a)}catch(e){console.error("Error when applying the variable:",e),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}async function S(i,a){const t=figma.currentPage.selection;if(t.length>0&&i)try{const e=await figma.variables.getVariableByIdAsync(i);if(!e){figma.notify("Error: Could not obtain the variable.");return}await N(t,e,a)}catch(e){console.error("Error when applying the variable:",e),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}figma.ui.onmessage=async i=>{if(i.type==="apply-variable"){const a=i.variableId,t=i.variableType,e=i.action;t==="color"?await T(a,e):t==="number"&&await S(a,e)}else i.type==="reload-variables"&&(await L(),figma.notify("ðŸ”„ Variables reloaded."))};L();
