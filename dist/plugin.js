var W=Object.defineProperty,E=Object.defineProperties;var P=Object.getOwnPropertyDescriptors;var N=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;var v=(i,e,a)=>e in i?W(i,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[e]=a,B=(i,e)=>{for(var a in e||(e={}))H.call(e,a)&&v(i,a,e[a]);if(N)for(var a of N(e))$.call(e,a)&&v(i,a,e[a]);return i},T=(i,e)=>E(i,P(e));var L=(i,e,a)=>v(i,typeof e!="symbol"?e+"":e,a);async function O(i){if(i.valuesByMode&&typeof i.valuesByMode=="object"){const e=Object.keys(i.valuesByMode);for(const a of e){const t=i.valuesByMode[a];if(t&&typeof t=="object"&&"type"in t&&t.type==="VARIABLE_ALIAS"&&t.id){const o=await figma.variables.getVariableByIdAsync(t.id);if(o){const r=await _(o);if(r!==void 0)return r}}else if(i.resolvedType==="COLOR"&&typeof t=="object"&&"r"in t){const o={r:t.r,g:t.g,b:t.b};return"a"in t&&(o.a=t.a),o}else if(i.resolvedType==="FLOAT"&&typeof t=="number")return t}}return null}async function _(i){return O(i)}function z(i,e,a){return new Promise((t,o)=>{const s=i.flatMap(g=>g.variables).filter(g=>g.scopes&&g.scopes.length>0);let n=0;const c=[];function f(){const g=s.slice(n,n+e);Promise.all(g.map(async u=>{const R=await O(u);c.push({alias:u.name||"No alias",id:u.id,value:R,type:u.resolvedType==="COLOR"?"color":"number",isRemote:u.remote,libraryName:i.find(p=>p.variables.includes(u)).libraryName,scopes:u.scopes||[],collectionName:i.find(p=>p.variables.includes(u)).collectionName})})).then(()=>{n+=e,n<s.length?setTimeout(f,0):(a(c),t())}).catch(o)}f()})}async function D(){try{const i=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const e of i){const a=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(e.key);for(const t of a)(t.resolvedType==="COLOR"||t.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(t.key)}figma.notify("✅ Variables imported correctly.")}catch(i){console.error("Error when importing remote variables:",i),figma.notify("🚨 Error when importing remote variables.")}}async function F(){try{figma.ui.postMessage({type:"loading-start"}),await D();const i=await figma.variables.getLocalVariableCollectionsAsync(),e=[];for(const r of i){const s=[];for(const n of r.variableIds){const c=await figma.variables.getVariableByIdAsync(n);((c==null?void 0:c.resolvedType)==="COLOR"||(c==null?void 0:c.resolvedType)==="FLOAT")&&s.push(c)}e.push({variables:s,libraryName:"Local",collectionName:r.name})}const a=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),t=[];for(const r of a){const s=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(r.key),n={variables:[],libraryName:r.libraryName,collectionName:r.name};for(const c of s)if(c.resolvedType==="COLOR"||c.resolvedType==="FLOAT"){const f=await figma.variables.importVariableByKeyAsync(c.key);n.variables.push(f)}t.push(n)}const o=[...e,...t];await z(o,50,async r=>{figma.ui.postMessage({type:"all-data",variables:r})})}catch(i){console.error("Error loading all variables :",i),figma.notify("🚨 Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const M=async(i,e,a)=>{const{scopes:t}=i;if(t.includes("ALL_SCOPES"))return!0;if(i.resolvedType==="COLOR"){if(e==="fill"&&"fills"in a)return t.includes("ALL_FILLS")||t.includes("FRAME_FILL")&&a.type==="FRAME"||t.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(a.type)?!0:t.includes("TEXT_FILL")&&a.type==="TEXT";if(e==="stroke"&&"strokes"in a)return t.includes("STROKE_COLOR")}else if(i.resolvedType==="FLOAT"){if(e==="spaceBetween"&&a.type==="FRAME")return t.includes("GAP");if(e==="borderRadius"&&"cornerRadius"in a)return t.includes("CORNER_RADIUS");if(e.includes("padding")&&a.type==="FRAME")return a.layoutMode==="NONE"?!1:t.includes("GAP");if(e==="strokeWidth"&&"strokeWeight"in a)return t.includes("STROKE_FLOAT")}return!1};class G{constructor(){L(this,"history",{actions:[],currentIndex:-1});L(this,"maxHistorySize",50)}captureNodeState(e){const a={nodeId:e.id,properties:{},boundVariables:{}};return"fills"in e&&(a.properties.fills=e.fills?JSON.parse(JSON.stringify(e.fills)):[]),"strokes"in e&&(a.properties.strokes=e.strokes?JSON.parse(JSON.stringify(e.strokes)):[],a.properties.strokeWeight=e.strokeWeight,"strokeTopWeight"in e&&(a.properties.strokeTopWeight=e.strokeTopWeight),"strokeRightWeight"in e&&(a.properties.strokeRightWeight=e.strokeRightWeight),"strokeBottomWeight"in e&&(a.properties.strokeBottomWeight=e.strokeBottomWeight),"strokeLeftWeight"in e&&(a.properties.strokeLeftWeight=e.strokeLeftWeight)),"topLeftRadius"in e&&(a.properties.topLeftRadius=e.topLeftRadius,a.properties.topRightRadius=e.topRightRadius,a.properties.bottomLeftRadius=e.bottomLeftRadius,a.properties.bottomRightRadius=e.bottomRightRadius),"layoutMode"in e&&(a.properties.layoutMode=e.layoutMode,a.properties.itemSpacing=e.itemSpacing,a.properties.paddingTop=e.paddingTop,a.properties.paddingBottom=e.paddingBottom,a.properties.paddingLeft=e.paddingLeft,a.properties.paddingRight=e.paddingRight),"boundVariables"in e&&e.boundVariables&&(a.boundVariables=JSON.parse(JSON.stringify(e.boundVariables))),a}async restoreNodeState(e){var a;try{const t=await figma.getNodeByIdAsync(e.nodeId);if(!t)return!1;const o=e.properties;if("fills"in t&&o.fills!==void 0&&(t.fills=o.fills),"strokes"in t&&(o.strokes!==void 0&&(t.strokes=o.strokes),o.strokeWeight!==void 0&&(t.strokeWeight=o.strokeWeight),o.strokeTopWeight!==void 0&&"strokeTopWeight"in t&&(t.strokeTopWeight=o.strokeTopWeight),o.strokeRightWeight!==void 0&&"strokeRightWeight"in t&&(t.strokeRightWeight=o.strokeRightWeight),o.strokeBottomWeight!==void 0&&"strokeBottomWeight"in t&&(t.strokeBottomWeight=o.strokeBottomWeight),o.strokeLeftWeight!==void 0&&"strokeLeftWeight"in t&&(t.strokeLeftWeight=o.strokeLeftWeight)),"topLeftRadius"in t&&(o.topLeftRadius!==void 0&&(t.topLeftRadius=o.topLeftRadius),o.topRightRadius!==void 0&&(t.topRightRadius=o.topRightRadius),o.bottomLeftRadius!==void 0&&(t.bottomLeftRadius=o.bottomLeftRadius),o.bottomRightRadius!==void 0&&(t.bottomRightRadius=o.bottomRightRadius)),"layoutMode"in t&&(o.layoutMode!==void 0&&(t.layoutMode=o.layoutMode),o.itemSpacing!==void 0&&(t.itemSpacing=o.itemSpacing),o.paddingTop!==void 0&&(t.paddingTop=o.paddingTop),o.paddingBottom!==void 0&&(t.paddingBottom=o.paddingBottom),o.paddingLeft!==void 0&&(t.paddingLeft=o.paddingLeft),o.paddingRight!==void 0&&(t.paddingRight=o.paddingRight)),"setBoundVariable"in t&&e.boundVariables){const r=e.boundVariables;for(const s in r)try{if(r[s]===null)t.setBoundVariable(s,null);else if((a=r[s])!=null&&a.id){const n=await figma.variables.getVariableByIdAsync(r[s].id);n&&t.setBoundVariable(s,n)}}catch(n){console.warn(`Failed to restore bound variable ${s}:`,n)}}return!0}catch(t){return console.error("Failed to restore node state:",t),!1}}addAction(e){this.history.actions=this.history.actions.slice(0,this.history.currentIndex+1),this.history.actions.push(e),this.history.currentIndex=this.history.actions.length-1,this.history.actions.length>this.maxHistorySize&&(this.history.actions.shift(),this.history.currentIndex--),this.notifyHistoryChanged()}async undo(){if(!this.canUndo())return!1;const e=this.history.actions[this.history.currentIndex];let a=!0;for(let t=0;t<e.afterState.length;t++){const o=e.afterState[t],r=e.beforeState[t];if(o.frameCreated&&o.originalNodeId)try{const s=await figma.getNodeByIdAsync(o.nodeId),n=await figma.getNodeByIdAsync(o.originalNodeId);if(s&&n&&s.parent&&"x"in s&&"x"in n){const c=s.parent,f=c.children.indexOf(s);c.insertChild(f,n),n.x=s.x,n.y=s.y,s.remove(),await this.restoreNodeState(r)}}catch(s){console.error("Failed to undo frame creation:",s),a=!1}else await this.restoreNodeState(r)||(a=!1)}return a?(this.history.currentIndex--,this.notifyHistoryChanged(),figma.notify(`↶ Undone: ${e.description}`)):figma.notify("⚠️ Failed to undo some changes"),a}async redo(){if(!this.canRedo())return!1;const e=this.history.actions[this.history.currentIndex+1];let a=!0;for(let t=0;t<e.afterState.length;t++){const o=e.afterState[t];if(o.frameCreated&&o.originalNodeId)try{const r=await figma.getNodeByIdAsync(o.originalNodeId);if(r&&r.parent&&"x"in r){const s=figma.createFrame();s.name=o.properties.name||`${r.name} Frame`,s.x=r.x,s.y=r.y,s.resize(r.width,r.height);const n=r.parent,c=n.children.indexOf(r);n.insertChild(c,s),s.appendChild(r),r.x=0,r.y=0;const f=T(B({},o),{nodeId:s.id});await this.restoreNodeState(f)}}catch(r){console.error("Failed to redo frame creation:",r),a=!1}else await this.restoreNodeState(o)||(a=!1)}return a?(this.history.currentIndex++,this.notifyHistoryChanged(),figma.notify(`↷ Redone: ${e.description}`)):figma.notify("⚠️ Failed to redo some changes"),a}canUndo(){return this.history.currentIndex>=0}canRedo(){return this.history.currentIndex<this.history.actions.length-1}getHistoryInfo(){var e,a;return{canUndo:this.canUndo(),canRedo:this.canRedo(),currentAction:this.history.currentIndex>=0?(e=this.history.actions[this.history.currentIndex])==null?void 0:e.description:null,nextAction:this.canRedo()?(a=this.history.actions[this.history.currentIndex+1])==null?void 0:a.description:null,totalActions:this.history.actions.length}}getFullHistoryInfo(){return{actions:this.history.actions,currentIndex:this.history.currentIndex,canUndo:this.canUndo(),canRedo:this.canRedo(),totalActions:this.history.actions.length}}async jumpToAction(e){if(e<-1||e>=this.history.actions.length)return!1;const a=this.history.currentIndex;if(e===a)return!0;if(e<a){for(;this.history.currentIndex>e;)if(!await this.undo())return!1}else for(;this.history.currentIndex<e;)if(!await this.redo())return!1;return!0}clearHistory(){this.history.actions=[],this.history.currentIndex=-1,this.notifyHistoryChanged()}notifyHistoryChanged(){figma.ui.postMessage({type:"history-changed",historyInfo:this.getHistoryInfo()})}}const y=new G;async function U(i,e,a){if(i.length>0&&e)try{let t=!1;const o=i.map(r=>y.captureNodeState(r));for(const r of i)if(await M(e,a,r)){if(a==="fill"&&"fills"in r)if(t=!0,Array.isArray(r.fills)&&r.fills.length>0){const n=[...r.fills];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.fills=n}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)];else if(a==="stroke"&&"strokes"in r)if(t=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const n=[...r.strokes];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.strokes=n}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)]}if(t){const r=i.map(c=>y.captureNodeState(c)),s=`Apply ${e.name} (${a})`,n={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:s,variableId:e.id,variableType:"color",action:a,beforeState:o,afterState:r};y.addAction(n),figma.notify("✅ Variable applied correctly.")}else figma.notify("🚫 Scope limitation.")}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}class j{constructor(){L(this,"pendingConfirmations",new Map)}async showConfirmation(e,a,t="Yes, proceed",o="Cancel"){const r=Date.now().toString()+Math.random().toString(36).substr(2,9);return new Promise(s=>{this.pendingConfirmations.set(r,{id:r,resolve:s}),figma.ui.postMessage({type:"show-confirmation",id:r,title:e,message:a,confirmText:t,cancelText:o})})}handleResponse(e,a){const t=this.pendingConfirmations.get(e);t&&(t.resolve(a),this.pendingConfirmations.delete(e))}}const C=new j,J=i=>{var o;const e=figma.createFrame();e.name=`${i.name} Frame`,e.x=i.x,e.y=i.y,e.resize(i.width,i.height);const a=i.parent,t=(o=a==null?void 0:a.children.indexOf(i))!=null?o:0;return a&&a.insertChild(t,e),e.appendChild(i),i.x=0,i.y=0,e.layoutMode="HORIZONTAL",e.layoutSizingHorizontal="HUG",e.layoutSizingVertical="HUG",e.paddingTop=0,e.paddingBottom=0,e.paddingLeft=0,e.paddingRight=0,e},q=i=>{let e="HORIZONTAL";if(i.children.length>=2){const a=i.children[0],t=i.children[1],o=Math.abs(a.x-t.x),r=Math.abs(a.y-t.y);e=o>r?"HORIZONTAL":"VERTICAL"}i.layoutMode=e,i.layoutSizingHorizontal="HUG",i.layoutSizingVertical="HUG"},K=async(i,e)=>{if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(e)){if(!("layoutMode"in i)){const t=e.includes("padding")?"padding":"spacing";if(!await C.showConfirmation(`Create Frame for ${t}?`,`This element needs to be wrapped in a frame to apply ${t} variables. Should I create a frame and move this element inside?`,"Yes, create frame","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires a frame. Operation cancelled.`};try{const r=J(i);return figma.currentPage.selection=[r],{success:!0,node:r,message:`✨ Created frame with Auto Layout for ${t}. Original node moved inside.`}}catch(r){return{success:!1,node:i,message:"🚨 Failed to create frame. Please manually wrap this element in a frame and enable Auto Layout."}}}const a=i;if(a.layoutMode==="NONE"){const t=e.includes("padding")?"padding":"spacing";if(!await C.showConfirmation(`Enable Auto Layout for ${t}?`,`This frame needs Auto Layout to apply ${t} variables. Should I enable Auto Layout?`,"Yes, enable Auto Layout","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires Auto Layout. Operation cancelled.`};try{return q(a),{success:!0,node:a,message:`✨ Auto Layout enabled for ${t}.`}}catch(r){return{success:!1,node:i,message:`🚨 Could not enable Auto Layout. Please enable it manually for ${t}.`}}}return{success:!0,node:i,message:""}}return{success:!0,node:i,message:""}},I=(i,e,a)=>{a==="vertical"?(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e)):a==="horizontal"?(i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e)):a==="general"&&(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e),i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e))},Y=(i,e)=>{"strokes"in i&&(Array.isArray(i.strokes)&&i.strokes.length>0&&i.strokes.some(t=>t.visible!==!1)||(i.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),i.setBoundVariable("strokeWeight",e),i.setBoundVariable("strokeTopWeight",e),i.setBoundVariable("strokeRightWeight",e),i.setBoundVariable("strokeBottomWeight",e),i.setBoundVariable("strokeLeftWeight",e)},Z=(i,e)=>{i.setBoundVariable("topLeftRadius",e),i.setBoundVariable("topRightRadius",e),i.setBoundVariable("bottomLeftRadius",e),i.setBoundVariable("bottomRightRadius",e)},X=(i,e)=>{const a=i.scopes;return a.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:e==="spaceBetween"&&a.includes("GAP")?{isCompatible:!0,warning:""}:e.includes("padding")&&a.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},Q=async(i,e,a)=>{var r,s,n,c,f,g,u,R;let t="";const o=[];for(const p of i){const A=y.captureNodeState(p);if(!await M(e,a,p)){t="🚫 Scope limitation.";continue}if(!("setBoundVariable"in p)){t="🚨 Node does not support variable binding.";continue}const{success:k,node:d,message:h}=await K(p,a);if(!k){t=h;continue}const w={originalNode:p,beforeState:A,finalNode:d,frameCreated:d!==p};o.push(w);const{isCompatible:x,warning:b}=X(e,a);switch(x||(t+=b),a){case"spaceBetween":d.setBoundVariable("itemSpacing",e),t=h?`✅ Spacing variable applied correctly. ${h}`:"✅ Spacing variable applied correctly.";break;case"borderRadius":Z(d,e),t="✅ Border radius variable applied correctly.";break;case"paddingVertical":if(d.type==="FRAME"){const m=d;try{I(m,e,"vertical");const l=m.boundVariables;((r=l==null?void 0:l.paddingTop)==null?void 0:r.id)===e.id||((s=l==null?void 0:l.paddingBottom)==null?void 0:s.id)===e.id?(t=h?`✅ Vertical padding variable applied correctly. ${h}`:"✅ Vertical padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(d.type==="FRAME"){const m=d;try{I(m,e,"horizontal");const l=m.boundVariables;((n=l==null?void 0:l.paddingLeft)==null?void 0:n.id)===e.id||((c=l==null?void 0:l.paddingRight)==null?void 0:c.id)===e.id?(t=h?`✅ Horizontal padding variable applied correctly. ${h}`:"✅ Horizontal padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(d.type==="FRAME"){const m=d;try{I(m,e,"general");const l=m.boundVariables;((f=l==null?void 0:l.paddingTop)==null?void 0:f.id)===e.id||((g=l==null?void 0:l.paddingBottom)==null?void 0:g.id)===e.id||((u=l==null?void 0:l.paddingLeft)==null?void 0:u.id)===e.id||((R=l==null?void 0:l.paddingRight)==null?void 0:R.id)===e.id?(t=h?`✅ Padding variable applied to all sides correctly. ${h}`:"✅ Padding variable applied to all sides correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in d&&(Y(d,e),t="✅ Stroke variable applied with dark border.");break;default:t="🚨 Unknown action."}const S=y.captureNodeState(d);w.frameCreated&&(S.frameCreated=!0,S.originalNodeId=p.id),w.afterState=S}if(t.includes("✅")&&o.length>0){const p=o.map(d=>d.beforeState),A=o.map(d=>d.afterState),V=`Apply ${e.name} (${a})`,k={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:V,variableId:e.id,variableType:"number",action:a,beforeState:p,afterState:A};y.addAction(k)}figma.notify(t)};figma.showUI(__html__,{width:240,height:664});async function ee(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await U(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}async function te(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await Q(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}figma.ui.onmessage=async i=>{if(i.type==="apply-variable"){const e=i.variableId,a=i.variableType,t=i.action;a==="color"?await ee(e,t):a==="number"&&await te(e,t)}else if(i.type==="reload-variables")await F(),figma.notify("🔄 Variables reloaded.");else if(i.type==="confirmation-response")C.handleResponse(i.id,i.confirmed);else if(i.type==="undo")await y.undo();else if(i.type==="redo")await y.redo();else if(i.type==="get-full-history"){const e=y.getFullHistoryInfo();figma.ui.postMessage({type:"full-history-response",historyInfo:e})}else i.type==="jump-to-action"&&(await y.jumpToAction(i.index)?i.index===-1?figma.notify("⭐ Jumped to initial state"):figma.notify(`↶ Jumped to action ${i.index+1}`):figma.notify("⚠️ Failed to jump to action"))};F();
