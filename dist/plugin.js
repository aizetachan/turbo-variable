var R=Object.defineProperty;var B=(e,i,t)=>i in e?R(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t;var w=(e,i,t)=>B(e,typeof i!="symbol"?i+"":i,t);async function V(e){if(e.valuesByMode&&typeof e.valuesByMode=="object"){const i=Object.keys(e.valuesByMode);for(const t of i){const a=e.valuesByMode[t];if(a&&typeof a=="object"&&"type"in a&&a.type==="VARIABLE_ALIAS"&&a.id){const r=await figma.variables.getVariableByIdAsync(a.id);if(r){const s=await S(r);if(s!==void 0)return s}}else if(e.resolvedType==="COLOR"&&typeof a=="object"&&"r"in a){const r={r:a.r,g:a.g,b:a.b};return"a"in a&&(r.a=a.a),r}else if(e.resolvedType==="FLOAT"&&typeof a=="number")return a}}return null}async function S(e){return V(e)}function T(e,i,t){return new Promise((a,r)=>{const n=e.flatMap(f=>f.variables).filter(f=>f.scopes&&f.scopes.length>0);let c=0;const l=[];function g(){const f=n.slice(c,c+i);Promise.all(f.map(async d=>{const b=await V(d);l.push({alias:d.name||"No alias",id:d.id,value:b,type:d.resolvedType==="COLOR"?"color":"number",isRemote:d.remote,libraryName:e.find(h=>h.variables.includes(d)).libraryName,scopes:d.scopes||[],collectionName:e.find(h=>h.variables.includes(d)).collectionName})})).then(()=>{c+=i,c<n.length?setTimeout(g,0):(t(l),a())}).catch(r)}g()})}async function N(){try{const e=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const i of e){const t=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(i.key);for(const a of t)(a.resolvedType==="COLOR"||a.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(a.key)}figma.notify("✅ Variables imported correctly.")}catch(e){console.error("Error when importing remote variables:",e),figma.notify("🚨 Error when importing remote variables.")}}async function C(){try{figma.ui.postMessage({type:"loading-start"}),await N();const e=await figma.variables.getLocalVariableCollectionsAsync(),i=[];for(const s of e){const n=[];for(const c of s.variableIds){const l=await figma.variables.getVariableByIdAsync(c);((l==null?void 0:l.resolvedType)==="COLOR"||(l==null?void 0:l.resolvedType)==="FLOAT")&&n.push(l)}i.push({variables:n,libraryName:"Local",collectionName:s.name})}const t=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),a=[];for(const s of t){const n=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(s.key),c={variables:[],libraryName:s.libraryName,collectionName:s.name};for(const l of n)if(l.resolvedType==="COLOR"||l.resolvedType==="FLOAT"){const g=await figma.variables.importVariableByKeyAsync(l.key);c.variables.push(g)}a.push(c)}const r=[...i,...a];await T(r,50,async s=>{figma.ui.postMessage({type:"all-data",variables:s})})}catch(e){console.error("Error loading all variables :",e),figma.notify("🚨 Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const O=async(e,i,t)=>{const{scopes:a}=e;if(a.includes("ALL_SCOPES"))return!0;if(e.resolvedType==="COLOR"){if(i==="fill"&&"fills"in t)return a.includes("ALL_FILLS")||a.includes("FRAME_FILL")&&t.type==="FRAME"||a.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(t.type)?!0:a.includes("TEXT_FILL")&&t.type==="TEXT";if(i==="stroke"&&"strokes"in t)return a.includes("STROKE_COLOR")}else if(e.resolvedType==="FLOAT"){if(i==="spaceBetween"&&t.type==="FRAME")return a.includes("GAP");if(i==="borderRadius"&&"cornerRadius"in t)return a.includes("CORNER_RADIUS");if(i.includes("padding")&&t.type==="FRAME")return t.layoutMode==="NONE"?!1:a.includes("GAP");if(i==="strokeWidth"&&"strokeWeight"in t)return a.includes("STROKE_FLOAT")}return!1};async function E(e,i,t){if(e.length>0&&i)try{let a=!1;for(const r of e)if(await O(i,t,r)){if(t==="fill"&&"fills"in r)if(a=!0,Array.isArray(r.fills)&&r.fills.length>0){const n=[...r.fills];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",i),r.fills=n}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",i)];else if(t==="stroke"&&"strokes"in r)if(a=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const n=[...r.strokes];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",i),r.strokes=n}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",i)]}a?figma.notify("✅ Variable applied correctly."):figma.notify("🚫 Scope limitation.")}catch(a){console.error("Error when applying the variable:",a),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}class F{constructor(){w(this,"pendingConfirmations",new Map)}async showConfirmation(i,t,a="Yes, proceed",r="Cancel"){const s=Date.now().toString()+Math.random().toString(36).substr(2,9);return new Promise(n=>{this.pendingConfirmations.set(s,{id:s,resolve:n}),figma.ui.postMessage({type:"show-confirmation",id:s,title:i,message:t,confirmText:a,cancelText:r})})}handleResponse(i,t){const a=this.pendingConfirmations.get(i);a&&(a.resolve(t),this.pendingConfirmations.delete(i))}}const A=new F,I=e=>{var r;const i=figma.createFrame();i.name=`${e.name} Frame`,i.x=e.x,i.y=e.y,i.resize(e.width,e.height);const t=e.parent,a=(r=t==null?void 0:t.children.indexOf(e))!=null?r:0;return t&&t.insertChild(a,i),i.appendChild(e),e.x=0,e.y=0,i.layoutMode="HORIZONTAL",i.layoutSizingHorizontal="HUG",i.layoutSizingVertical="HUG",i.paddingTop=0,i.paddingBottom=0,i.paddingLeft=0,i.paddingRight=0,i},M=e=>{let i="HORIZONTAL";if(e.children.length>=2){const t=e.children[0],a=e.children[1],r=Math.abs(t.x-a.x),s=Math.abs(t.y-a.y);i=r>s?"HORIZONTAL":"VERTICAL"}e.layoutMode=i,e.layoutSizingHorizontal="HUG",e.layoutSizingVertical="HUG"},P=async(e,i)=>{if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(i)){if(!("layoutMode"in e)){const a=i.includes("padding")?"padding":"spacing";if(!await A.showConfirmation(`Create Frame for ${a}?`,`This element needs to be wrapped in a frame to apply ${a} variables. Should I create a frame and move this element inside?`,"Yes, create frame","Cancel"))return{success:!1,node:e,message:`❌ ${a} requires a frame. Operation cancelled.`};try{const s=I(e);return figma.currentPage.selection=[s],{success:!0,node:s,message:`✨ Created frame with Auto Layout for ${a}. Original node moved inside.`}}catch(s){return{success:!1,node:e,message:"🚨 Failed to create frame. Please manually wrap this element in a frame and enable Auto Layout."}}}const t=e;if(t.layoutMode==="NONE"){const a=i.includes("padding")?"padding":"spacing";if(!await A.showConfirmation(`Enable Auto Layout for ${a}?`,`This frame needs Auto Layout to apply ${a} variables. Should I enable Auto Layout?`,"Yes, enable Auto Layout","Cancel"))return{success:!1,node:e,message:`❌ ${a} requires Auto Layout. Operation cancelled.`};try{return M(t),{success:!0,node:t,message:`✨ Auto Layout enabled for ${a}.`}}catch(s){return{success:!1,node:e,message:`🚨 Could not enable Auto Layout. Please enable it manually for ${a}.`}}}return{success:!0,node:e,message:""}}return{success:!0,node:e,message:""}},L=(e,i,t)=>{t==="vertical"?(e.setBoundVariable("paddingTop",i),e.setBoundVariable("paddingBottom",i)):t==="horizontal"?(e.setBoundVariable("paddingLeft",i),e.setBoundVariable("paddingRight",i)):t==="general"&&(e.setBoundVariable("paddingTop",i),e.setBoundVariable("paddingBottom",i),e.setBoundVariable("paddingLeft",i),e.setBoundVariable("paddingRight",i))},_=(e,i)=>{"strokes"in e&&(Array.isArray(e.strokes)&&e.strokes.length>0&&e.strokes.some(a=>a.visible!==!1)||(e.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),e.setBoundVariable("strokeWeight",i),e.setBoundVariable("strokeTopWeight",i),e.setBoundVariable("strokeRightWeight",i),e.setBoundVariable("strokeBottomWeight",i),e.setBoundVariable("strokeLeftWeight",i)},G=(e,i)=>{e.setBoundVariable("topLeftRadius",i),e.setBoundVariable("topRightRadius",i),e.setBoundVariable("bottomLeftRadius",i),e.setBoundVariable("bottomRightRadius",i)},H=(e,i)=>{const t=e.scopes;return t.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:i==="spaceBetween"&&t.includes("GAP")?{isCompatible:!0,warning:""}:i.includes("padding")&&t.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},$=async(e,i,t)=>{var r,s,n,c,l,g,f,d;let a="";for(const b of e){if(!await O(i,t,b)){a="🚫 Scope limitation.";continue}if(!("setBoundVariable"in b)){a="🚨 Node does not support variable binding.";continue}const{success:v,node:p,message:y}=await P(b,t);if(!v){a=y;continue}const{isCompatible:k,warning:m}=H(i,t);switch(k||(a+=m),t){case"spaceBetween":p.setBoundVariable("itemSpacing",i),a=y?`✅ Spacing variable applied correctly. ${y}`:"✅ Spacing variable applied correctly.";break;case"borderRadius":G(p,i),a="✅ Border radius variable applied correctly.";break;case"paddingVertical":if(p.type==="FRAME"){const u=p;try{L(u,i,"vertical");const o=u.boundVariables;((r=o==null?void 0:o.paddingTop)==null?void 0:r.id)===i.id||((s=o==null?void 0:o.paddingBottom)==null?void 0:s.id)===i.id?(a=y?`✅ Vertical padding variable applied correctly. ${y}`:"✅ Vertical padding variable applied correctly.",m&&(a+=`
💡 `+m)):a="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(p.type==="FRAME"){const u=p;try{L(u,i,"horizontal");const o=u.boundVariables;((n=o==null?void 0:o.paddingLeft)==null?void 0:n.id)===i.id||((c=o==null?void 0:o.paddingRight)==null?void 0:c.id)===i.id?(a=y?`✅ Horizontal padding variable applied correctly. ${y}`:"✅ Horizontal padding variable applied correctly.",m&&(a+=`
💡 `+m)):a="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(p.type==="FRAME"){const u=p;try{L(u,i,"general");const o=u.boundVariables;((l=o==null?void 0:o.paddingTop)==null?void 0:l.id)===i.id||((g=o==null?void 0:o.paddingBottom)==null?void 0:g.id)===i.id||((f=o==null?void 0:o.paddingLeft)==null?void 0:f.id)===i.id||((d=o==null?void 0:o.paddingRight)==null?void 0:d.id)===i.id?(a=y?`✅ Padding variable applied to all sides correctly. ${y}`:"✅ Padding variable applied to all sides correctly.",m&&(a+=`
💡 `+m)):a="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in p&&(_(p,i),a="✅ Stroke variable applied with dark border.");break;default:a="🚨 Unknown action."}}figma.notify(a)};figma.showUI(__html__,{width:240,height:664});async function z(e,i){const t=figma.currentPage.selection;if(t.length>0&&e)try{const a=await figma.variables.getVariableByIdAsync(e);if(!a){figma.notify("Error: Could not obtain the variable.");return}await E(t,a,i)}catch(a){console.error("Error when applying the variable:",a),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}async function x(e,i){const t=figma.currentPage.selection;if(t.length>0&&e)try{const a=await figma.variables.getVariableByIdAsync(e);if(!a){figma.notify("Error: Could not obtain the variable.");return}await $(t,a,i)}catch(a){console.error("Error when applying the variable:",a),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}figma.ui.onmessage=async e=>{if(e.type==="apply-variable"){const i=e.variableId,t=e.variableType,a=e.action;t==="color"?await z(i,a):t==="number"&&await x(i,a)}else e.type==="reload-variables"?(await C(),figma.notify("🔄 Variables reloaded.")):e.type==="confirmation-response"&&A.handleResponse(e.id,e.confirmed)};C();
