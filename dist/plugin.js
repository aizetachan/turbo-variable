var I=Object.defineProperty;var O=(i,e,a)=>e in i?I(i,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[e]=a;var R=(i,e,a)=>O(i,typeof e!="symbol"?e+"":e,a);async function v(i){if(i.valuesByMode&&typeof i.valuesByMode=="object"){const e=Object.keys(i.valuesByMode);for(const a of e){const t=i.valuesByMode[a];if(t&&typeof t=="object"&&"type"in t&&t.type==="VARIABLE_ALIAS"&&t.id){const o=await figma.variables.getVariableByIdAsync(t.id);if(o){const r=await T(o);if(r!==void 0)return r}}else if(i.resolvedType==="COLOR"&&typeof t=="object"&&"r"in t){const o={r:t.r,g:t.g,b:t.b};return"a"in t&&(o.a=t.a),o}else if(i.resolvedType==="FLOAT"&&typeof t=="number")return t}}return null}async function T(i){return v(i)}function N(i,e,a){return new Promise((t,o)=>{const l=i.flatMap(g=>g.variables).filter(g=>g.scopes&&g.scopes.length>0);let n=0;const c=[];function m(){const g=l.slice(n,n+e);Promise.all(g.map(async p=>{const L=await v(p);c.push({alias:p.name||"No alias",id:p.id,value:L,type:p.resolvedType==="COLOR"?"color":"number",isRemote:p.remote,libraryName:i.find(f=>f.variables.includes(p)).libraryName,scopes:p.scopes||[],collectionName:i.find(f=>f.variables.includes(p)).collectionName})})).then(()=>{n+=e,n<l.length?setTimeout(m,0):(a(c),t())}).catch(o)}m()})}async function M(){try{const i=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const e of i){const a=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(e.key);for(const t of a)(t.resolvedType==="COLOR"||t.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(t.key)}figma.notify("✅ Variables imported correctly.")}catch(i){console.error("Error when importing remote variables:",i),figma.notify("🚨 Error when importing remote variables.")}}async function V(){try{figma.ui.postMessage({type:"loading-start"}),await M();const i=await figma.variables.getLocalVariableCollectionsAsync(),e=[];for(const r of i){const l=[];for(const n of r.variableIds){const c=await figma.variables.getVariableByIdAsync(n);((c==null?void 0:c.resolvedType)==="COLOR"||(c==null?void 0:c.resolvedType)==="FLOAT")&&l.push(c)}e.push({variables:l,libraryName:"Local",collectionName:r.name})}const a=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),t=[];for(const r of a){const l=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(r.key),n={variables:[],libraryName:r.libraryName,collectionName:r.name};for(const c of l)if(c.resolvedType==="COLOR"||c.resolvedType==="FLOAT"){const m=await figma.variables.importVariableByKeyAsync(c.key);n.variables.push(m)}t.push(n)}const o=[...e,...t];await N(o,50,async r=>{figma.ui.postMessage({type:"all-data",variables:r})})}catch(i){console.error("Error loading all variables :",i),figma.notify("🚨 Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const C=async(i,e,a)=>{const{scopes:t}=i;if(t.includes("ALL_SCOPES"))return!0;if(i.resolvedType==="COLOR"){if(e==="fill"&&"fills"in a)return t.includes("ALL_FILLS")||t.includes("FRAME_FILL")&&a.type==="FRAME"||t.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(a.type)?!0:t.includes("TEXT_FILL")&&a.type==="TEXT";if(e==="stroke"&&"strokes"in a)return t.includes("STROKE_COLOR")}else if(i.resolvedType==="FLOAT"){if(e==="spaceBetween"&&a.type==="FRAME")return t.includes("GAP");if(e==="borderRadius"&&"cornerRadius"in a)return t.includes("CORNER_RADIUS");if(e.includes("padding")&&a.type==="FRAME")return a.layoutMode==="NONE"?!1:t.includes("GAP");if(e==="strokeWidth"&&"strokeWeight"in a)return t.includes("STROKE_FLOAT")}return!1};class W{constructor(){R(this,"history",{actions:[],currentIndex:-1});R(this,"maxHistorySize",50)}captureNodeState(e){const a={nodeId:e.id,properties:{},boundVariables:{}};return"fills"in e&&(a.properties.fills=e.fills?JSON.parse(JSON.stringify(e.fills)):[]),"strokes"in e&&(a.properties.strokes=e.strokes?JSON.parse(JSON.stringify(e.strokes)):[],a.properties.strokeWeight=e.strokeWeight,"strokeTopWeight"in e&&(a.properties.strokeTopWeight=e.strokeTopWeight),"strokeRightWeight"in e&&(a.properties.strokeRightWeight=e.strokeRightWeight),"strokeBottomWeight"in e&&(a.properties.strokeBottomWeight=e.strokeBottomWeight),"strokeLeftWeight"in e&&(a.properties.strokeLeftWeight=e.strokeLeftWeight)),"topLeftRadius"in e&&(a.properties.topLeftRadius=e.topLeftRadius,a.properties.topRightRadius=e.topRightRadius,a.properties.bottomLeftRadius=e.bottomLeftRadius,a.properties.bottomRightRadius=e.bottomRightRadius),"layoutMode"in e&&(a.properties.layoutMode=e.layoutMode,a.properties.itemSpacing=e.itemSpacing,a.properties.paddingTop=e.paddingTop,a.properties.paddingBottom=e.paddingBottom,a.properties.paddingLeft=e.paddingLeft,a.properties.paddingRight=e.paddingRight),"boundVariables"in e&&e.boundVariables&&(a.boundVariables=JSON.parse(JSON.stringify(e.boundVariables))),a}async restoreNodeState(e){var a;try{const t=await figma.getNodeByIdAsync(e.nodeId);if(!t)return!1;const o=e.properties;if("fills"in t&&o.fills!==void 0&&(t.fills=o.fills),"strokes"in t&&(o.strokes!==void 0&&(t.strokes=o.strokes),o.strokeWeight!==void 0&&(t.strokeWeight=o.strokeWeight),o.strokeTopWeight!==void 0&&"strokeTopWeight"in t&&(t.strokeTopWeight=o.strokeTopWeight),o.strokeRightWeight!==void 0&&"strokeRightWeight"in t&&(t.strokeRightWeight=o.strokeRightWeight),o.strokeBottomWeight!==void 0&&"strokeBottomWeight"in t&&(t.strokeBottomWeight=o.strokeBottomWeight),o.strokeLeftWeight!==void 0&&"strokeLeftWeight"in t&&(t.strokeLeftWeight=o.strokeLeftWeight)),"topLeftRadius"in t&&(o.topLeftRadius!==void 0&&(t.topLeftRadius=o.topLeftRadius),o.topRightRadius!==void 0&&(t.topRightRadius=o.topRightRadius),o.bottomLeftRadius!==void 0&&(t.bottomLeftRadius=o.bottomLeftRadius),o.bottomRightRadius!==void 0&&(t.bottomRightRadius=o.bottomRightRadius)),"layoutMode"in t&&(o.layoutMode!==void 0&&(t.layoutMode=o.layoutMode),o.itemSpacing!==void 0&&(t.itemSpacing=o.itemSpacing),o.paddingTop!==void 0&&(t.paddingTop=o.paddingTop),o.paddingBottom!==void 0&&(t.paddingBottom=o.paddingBottom),o.paddingLeft!==void 0&&(t.paddingLeft=o.paddingLeft),o.paddingRight!==void 0&&(t.paddingRight=o.paddingRight)),"setBoundVariable"in t&&e.boundVariables){const r=e.boundVariables;for(const l in r)try{if(r[l]===null)t.setBoundVariable(l,null);else if((a=r[l])!=null&&a.id){const n=await figma.variables.getVariableByIdAsync(r[l].id);n&&t.setBoundVariable(l,n)}}catch(n){console.warn(`Failed to restore bound variable ${l}:`,n)}}return!0}catch(t){return console.error("Failed to restore node state:",t),!1}}addAction(e){this.history.actions=this.history.actions.slice(0,this.history.currentIndex+1),this.history.actions.push(e),this.history.currentIndex=this.history.actions.length-1,this.history.actions.length>this.maxHistorySize&&(this.history.actions.shift(),this.history.currentIndex--),this.notifyHistoryChanged()}async undo(){if(!this.canUndo())return!1;const e=this.history.actions[this.history.currentIndex];let a=!0;for(const t of e.beforeState)await this.restoreNodeState(t)||(a=!1);return a?(this.history.currentIndex--,this.notifyHistoryChanged(),figma.notify(`↶ Undone: ${e.description}`)):figma.notify("⚠️ Failed to undo some changes"),a}async redo(){if(!this.canRedo())return!1;const e=this.history.actions[this.history.currentIndex+1];let a=!0;for(const t of e.afterState)await this.restoreNodeState(t)||(a=!1);return a?(this.history.currentIndex++,this.notifyHistoryChanged(),figma.notify(`↷ Redone: ${e.description}`)):figma.notify("⚠️ Failed to redo some changes"),a}canUndo(){return this.history.currentIndex>=0}canRedo(){return this.history.currentIndex<this.history.actions.length-1}getHistoryInfo(){var e,a;return{canUndo:this.canUndo(),canRedo:this.canRedo(),currentAction:this.history.currentIndex>=0?(e=this.history.actions[this.history.currentIndex])==null?void 0:e.description:null,nextAction:this.canRedo()?(a=this.history.actions[this.history.currentIndex+1])==null?void 0:a.description:null,totalActions:this.history.actions.length}}clearHistory(){this.history.actions=[],this.history.currentIndex=-1,this.notifyHistoryChanged()}notifyHistoryChanged(){figma.ui.postMessage({type:"history-changed",historyInfo:this.getHistoryInfo()})}}const h=new W;async function F(i,e,a){if(i.length>0&&e)try{let t=!1;const o=i.map(r=>h.captureNodeState(r));for(const r of i)if(await C(e,a,r)){if(a==="fill"&&"fills"in r)if(t=!0,Array.isArray(r.fills)&&r.fills.length>0){const n=[...r.fills];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.fills=n}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)];else if(a==="stroke"&&"strokes"in r)if(t=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const n=[...r.strokes];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.strokes=n}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)]}if(t){const r=i.map(c=>h.captureNodeState(c)),l=`Apply ${e.name} (${a})`,n={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:l,variableId:e.id,variableType:"color",action:a,beforeState:o,afterState:r};h.addAction(n),figma.notify("✅ Variable applied correctly.")}else figma.notify("🚫 Scope limitation.")}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}class E{constructor(){R(this,"pendingConfirmations",new Map)}async showConfirmation(e,a,t="Yes, proceed",o="Cancel"){const r=Date.now().toString()+Math.random().toString(36).substr(2,9);return new Promise(l=>{this.pendingConfirmations.set(r,{id:r,resolve:l}),figma.ui.postMessage({type:"show-confirmation",id:r,title:e,message:a,confirmText:t,cancelText:o})})}handleResponse(e,a){const t=this.pendingConfirmations.get(e);t&&(t.resolve(a),this.pendingConfirmations.delete(e))}}const w=new E,P=i=>{var o;const e=figma.createFrame();e.name=`${i.name} Frame`,e.x=i.x,e.y=i.y,e.resize(i.width,i.height);const a=i.parent,t=(o=a==null?void 0:a.children.indexOf(i))!=null?o:0;return a&&a.insertChild(t,e),e.appendChild(i),i.x=0,i.y=0,e.layoutMode="HORIZONTAL",e.layoutSizingHorizontal="HUG",e.layoutSizingVertical="HUG",e.paddingTop=0,e.paddingBottom=0,e.paddingLeft=0,e.paddingRight=0,e},x=i=>{let e="HORIZONTAL";if(i.children.length>=2){const a=i.children[0],t=i.children[1],o=Math.abs(a.x-t.x),r=Math.abs(a.y-t.y);e=o>r?"HORIZONTAL":"VERTICAL"}i.layoutMode=e,i.layoutSizingHorizontal="HUG",i.layoutSizingVertical="HUG"},H=async(i,e)=>{if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(e)){if(!("layoutMode"in i)){const t=e.includes("padding")?"padding":"spacing";if(!await w.showConfirmation(`Create Frame for ${t}?`,`This element needs to be wrapped in a frame to apply ${t} variables. Should I create a frame and move this element inside?`,"Yes, create frame","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires a frame. Operation cancelled.`};try{const r=P(i);return figma.currentPage.selection=[r],{success:!0,node:r,message:`✨ Created frame with Auto Layout for ${t}. Original node moved inside.`}}catch(r){return{success:!1,node:i,message:"🚨 Failed to create frame. Please manually wrap this element in a frame and enable Auto Layout."}}}const a=i;if(a.layoutMode==="NONE"){const t=e.includes("padding")?"padding":"spacing";if(!await w.showConfirmation(`Enable Auto Layout for ${t}?`,`This frame needs Auto Layout to apply ${t} variables. Should I enable Auto Layout?`,"Yes, enable Auto Layout","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires Auto Layout. Operation cancelled.`};try{return x(a),{success:!0,node:a,message:`✨ Auto Layout enabled for ${t}.`}}catch(r){return{success:!1,node:i,message:`🚨 Could not enable Auto Layout. Please enable it manually for ${t}.`}}}return{success:!0,node:i,message:""}}return{success:!0,node:i,message:""}},A=(i,e,a)=>{a==="vertical"?(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e)):a==="horizontal"?(i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e)):a==="general"&&(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e),i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e))},$=(i,e)=>{"strokes"in i&&(Array.isArray(i.strokes)&&i.strokes.length>0&&i.strokes.some(t=>t.visible!==!1)||(i.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),i.setBoundVariable("strokeWeight",e),i.setBoundVariable("strokeTopWeight",e),i.setBoundVariable("strokeRightWeight",e),i.setBoundVariable("strokeBottomWeight",e),i.setBoundVariable("strokeLeftWeight",e)},_=(i,e)=>{i.setBoundVariable("topLeftRadius",e),i.setBoundVariable("topRightRadius",e),i.setBoundVariable("bottomLeftRadius",e),i.setBoundVariable("bottomRightRadius",e)},D=(i,e)=>{const a=i.scopes;return a.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:e==="spaceBetween"&&a.includes("GAP")?{isCompatible:!0,warning:""}:e.includes("padding")&&a.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},z=async(i,e,a)=>{var r,l,n,c,m,g,p,L;let t="";const o=i.map(f=>h.captureNodeState(f));for(const f of i){if(!await C(e,a,f)){t="🚫 Scope limitation.";continue}if(!("setBoundVariable"in f)){t="🚨 Node does not support variable binding.";continue}const{success:k,node:d,message:u}=await H(f,a);if(!k){t=u;continue}const{isCompatible:B,warning:b}=D(e,a);switch(B||(t+=b),a){case"spaceBetween":d.setBoundVariable("itemSpacing",e),t=u?`✅ Spacing variable applied correctly. ${u}`:"✅ Spacing variable applied correctly.";break;case"borderRadius":_(d,e),t="✅ Border radius variable applied correctly.";break;case"paddingVertical":if(d.type==="FRAME"){const y=d;try{A(y,e,"vertical");const s=y.boundVariables;((r=s==null?void 0:s.paddingTop)==null?void 0:r.id)===e.id||((l=s==null?void 0:s.paddingBottom)==null?void 0:l.id)===e.id?(t=u?`✅ Vertical padding variable applied correctly. ${u}`:"✅ Vertical padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(s){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(d.type==="FRAME"){const y=d;try{A(y,e,"horizontal");const s=y.boundVariables;((n=s==null?void 0:s.paddingLeft)==null?void 0:n.id)===e.id||((c=s==null?void 0:s.paddingRight)==null?void 0:c.id)===e.id?(t=u?`✅ Horizontal padding variable applied correctly. ${u}`:"✅ Horizontal padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(s){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(d.type==="FRAME"){const y=d;try{A(y,e,"general");const s=y.boundVariables;((m=s==null?void 0:s.paddingTop)==null?void 0:m.id)===e.id||((g=s==null?void 0:s.paddingBottom)==null?void 0:g.id)===e.id||((p=s==null?void 0:s.paddingLeft)==null?void 0:p.id)===e.id||((L=s==null?void 0:s.paddingRight)==null?void 0:L.id)===e.id?(t=u?`✅ Padding variable applied to all sides correctly. ${u}`:"✅ Padding variable applied to all sides correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(s){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in d&&($(d,e),t="✅ Stroke variable applied with dark border.");break;default:t="🚨 Unknown action."}}if(t.includes("✅")){const f=i.map(d=>h.captureNodeState(d)),S=`Apply ${e.name} (${a})`,k={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:S,variableId:e.id,variableType:"number",action:a,beforeState:o,afterState:f};h.addAction(k)}figma.notify(t)};figma.showUI(__html__,{width:240,height:664});async function G(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await F(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}async function U(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await z(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}figma.ui.onmessage=async i=>{if(i.type==="apply-variable"){const e=i.variableId,a=i.variableType,t=i.action;a==="color"?await G(e,t):a==="number"&&await U(e,t)}else i.type==="reload-variables"?(await V(),figma.notify("🔄 Variables reloaded.")):i.type==="confirmation-response"?w.handleResponse(i.id,i.confirmed):i.type==="undo"?await h.undo():i.type==="redo"&&await h.redo()};V();
