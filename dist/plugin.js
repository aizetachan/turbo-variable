var x=Object.defineProperty,E=Object.defineProperties;var P=Object.getOwnPropertyDescriptors;var N=Object.getOwnPropertySymbols;var H=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;var v=(i,e,a)=>e in i?x(i,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[e]=a,B=(i,e)=>{for(var a in e||(e={}))H.call(e,a)&&v(i,a,e[a]);if(N)for(var a of N(e))$.call(e,a)&&v(i,a,e[a]);return i},O=(i,e)=>E(i,P(e));var R=(i,e,a)=>v(i,typeof e!="symbol"?e+"":e,a);async function T(i){if(i.valuesByMode&&typeof i.valuesByMode=="object"){const e=Object.keys(i.valuesByMode);for(const a of e){const t=i.valuesByMode[a];if(t&&typeof t=="object"&&"type"in t&&t.type==="VARIABLE_ALIAS"&&t.id){const o=await figma.variables.getVariableByIdAsync(t.id);if(o){const r=await _(o);if(r!==void 0)return r}}else if(i.resolvedType==="COLOR"&&typeof t=="object"&&"r"in t){const o={r:t.r,g:t.g,b:t.b};return"a"in t&&(o.a=t.a),o}else if(i.resolvedType==="FLOAT"&&typeof t=="number")return t}}return null}async function _(i){return T(i)}function z(i,e,a){return new Promise((t,o)=>{const s=i.flatMap(y=>y.variables).filter(y=>y.scopes&&y.scopes.length>0);let n=0;const c=[];function f(){const y=s.slice(n,n+e);Promise.all(y.map(async g=>{const L=await T(g);c.push({alias:g.name||"No alias",id:g.id,value:L,type:g.resolvedType==="COLOR"?"color":"number",isRemote:g.remote,libraryName:i.find(p=>p.variables.includes(g)).libraryName,scopes:g.scopes||[],collectionName:i.find(p=>p.variables.includes(g)).collectionName})})).then(()=>{n+=e,n<s.length?setTimeout(f,0):(a(c),t())}).catch(o)}f()})}async function D(){try{const i=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const e of i){const a=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(e.key);for(const t of a)(t.resolvedType==="COLOR"||t.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(t.key)}figma.notify("✅ Variables imported correctly.")}catch(i){console.error("Error when importing remote variables:",i),figma.notify("🚨 Error when importing remote variables.")}}async function F(){try{figma.ui.postMessage({type:"loading-start"}),await D();const i=await figma.variables.getLocalVariableCollectionsAsync(),e=[];for(const r of i){const s=[];for(const n of r.variableIds){const c=await figma.variables.getVariableByIdAsync(n);((c==null?void 0:c.resolvedType)==="COLOR"||(c==null?void 0:c.resolvedType)==="FLOAT")&&s.push(c)}e.push({variables:s,libraryName:"Local",collectionName:r.name})}const a=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),t=[];for(const r of a){const s=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(r.key),n={variables:[],libraryName:r.libraryName,collectionName:r.name};for(const c of s)if(c.resolvedType==="COLOR"||c.resolvedType==="FLOAT"){const f=await figma.variables.importVariableByKeyAsync(c.key);n.variables.push(f)}t.push(n)}const o=[...e,...t];await z(o,50,async r=>{figma.ui.postMessage({type:"all-data",variables:r})})}catch(i){console.error("Error loading all variables :",i),figma.notify("🚨 Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const M=async(i,e,a)=>{const{scopes:t}=i;if(t.includes("ALL_SCOPES"))return!0;if(i.resolvedType==="COLOR"){if(e==="fill"&&"fills"in a)return t.includes("ALL_FILLS")||t.includes("FRAME_FILL")&&a.type==="FRAME"||t.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(a.type)?!0:t.includes("TEXT_FILL")&&a.type==="TEXT";if(e==="stroke"&&"strokes"in a)return t.includes("STROKE_COLOR")}else if(i.resolvedType==="FLOAT"){if(e==="spaceBetween"&&a.type==="FRAME")return t.includes("GAP");if(e==="borderRadius"&&"cornerRadius"in a)return t.includes("CORNER_RADIUS");if(e.includes("padding")&&a.type==="FRAME")return a.layoutMode==="NONE"?!1:t.includes("GAP");if(e==="strokeWidth"&&"strokeWeight"in a)return t.includes("STROKE_FLOAT")}return!1};class G{constructor(){R(this,"history",{actions:[],currentIndex:-1});R(this,"maxHistorySize",50)}captureNodeState(e){const a={nodeId:e.id,properties:{},boundVariables:{}};return"fills"in e&&(a.properties.fills=e.fills?JSON.parse(JSON.stringify(e.fills)):[]),"strokes"in e&&(a.properties.strokes=e.strokes?JSON.parse(JSON.stringify(e.strokes)):[],a.properties.strokeWeight=e.strokeWeight,"strokeTopWeight"in e&&(a.properties.strokeTopWeight=e.strokeTopWeight),"strokeRightWeight"in e&&(a.properties.strokeRightWeight=e.strokeRightWeight),"strokeBottomWeight"in e&&(a.properties.strokeBottomWeight=e.strokeBottomWeight),"strokeLeftWeight"in e&&(a.properties.strokeLeftWeight=e.strokeLeftWeight)),"topLeftRadius"in e&&(a.properties.topLeftRadius=e.topLeftRadius,a.properties.topRightRadius=e.topRightRadius,a.properties.bottomLeftRadius=e.bottomLeftRadius,a.properties.bottomRightRadius=e.bottomRightRadius),"layoutMode"in e&&(a.properties.layoutMode=e.layoutMode,a.properties.itemSpacing=e.itemSpacing,a.properties.paddingTop=e.paddingTop,a.properties.paddingBottom=e.paddingBottom,a.properties.paddingLeft=e.paddingLeft,a.properties.paddingRight=e.paddingRight),"boundVariables"in e&&e.boundVariables&&(a.boundVariables=JSON.parse(JSON.stringify(e.boundVariables))),a}async restoreNodeState(e){var a;try{const t=await figma.getNodeByIdAsync(e.nodeId);if(!t)return!1;const o=e.properties;if("fills"in t&&o.fills!==void 0&&(t.fills=o.fills),"strokes"in t&&(o.strokes!==void 0&&(t.strokes=o.strokes),o.strokeWeight!==void 0&&(t.strokeWeight=o.strokeWeight),o.strokeTopWeight!==void 0&&"strokeTopWeight"in t&&(t.strokeTopWeight=o.strokeTopWeight),o.strokeRightWeight!==void 0&&"strokeRightWeight"in t&&(t.strokeRightWeight=o.strokeRightWeight),o.strokeBottomWeight!==void 0&&"strokeBottomWeight"in t&&(t.strokeBottomWeight=o.strokeBottomWeight),o.strokeLeftWeight!==void 0&&"strokeLeftWeight"in t&&(t.strokeLeftWeight=o.strokeLeftWeight)),"topLeftRadius"in t&&(o.topLeftRadius!==void 0&&(t.topLeftRadius=o.topLeftRadius),o.topRightRadius!==void 0&&(t.topRightRadius=o.topRightRadius),o.bottomLeftRadius!==void 0&&(t.bottomLeftRadius=o.bottomLeftRadius),o.bottomRightRadius!==void 0&&(t.bottomRightRadius=o.bottomRightRadius)),"layoutMode"in t&&(o.layoutMode!==void 0&&(t.layoutMode=o.layoutMode),o.itemSpacing!==void 0&&(t.itemSpacing=o.itemSpacing),o.paddingTop!==void 0&&(t.paddingTop=o.paddingTop),o.paddingBottom!==void 0&&(t.paddingBottom=o.paddingBottom),o.paddingLeft!==void 0&&(t.paddingLeft=o.paddingLeft),o.paddingRight!==void 0&&(t.paddingRight=o.paddingRight)),"setBoundVariable"in t&&e.boundVariables){const r=e.boundVariables;for(const s in r)try{if(r[s]===null)t.setBoundVariable(s,null);else if((a=r[s])!=null&&a.id){const n=await figma.variables.getVariableByIdAsync(r[s].id);n&&t.setBoundVariable(s,n)}}catch(n){console.warn(`Failed to restore bound variable ${s}:`,n)}}return!0}catch(t){return console.error("Failed to restore node state:",t),!1}}addAction(e){this.history.actions=this.history.actions.slice(0,this.history.currentIndex+1),this.history.actions.push(e),this.history.currentIndex=this.history.actions.length-1,this.history.actions.length>this.maxHistorySize&&(this.history.actions.shift(),this.history.currentIndex--),this.notifyHistoryChanged()}async undo(){if(!this.canUndo())return!1;const e=this.history.actions[this.history.currentIndex];let a=!0;for(let t=0;t<e.afterState.length;t++){const o=e.afterState[t],r=e.beforeState[t];if(o.frameCreated&&o.originalNodeId)try{const s=await figma.getNodeByIdAsync(o.nodeId),n=await figma.getNodeByIdAsync(o.originalNodeId);if(s&&n&&s.parent&&"x"in s&&"x"in n){const c=s.parent,f=c.children.indexOf(s);c.insertChild(f,n),n.x=s.x,n.y=s.y,s.remove(),await this.restoreNodeState(r)}}catch(s){console.error("Failed to undo frame creation:",s),a=!1}else await this.restoreNodeState(r)||(a=!1)}return a?(this.history.currentIndex--,this.notifyHistoryChanged(),figma.notify(`↶ Undone: ${e.description}`)):figma.notify("⚠️ Failed to undo some changes"),a}async redo(){if(!this.canRedo())return!1;const e=this.history.actions[this.history.currentIndex+1];let a=!0;for(let t=0;t<e.afterState.length;t++){const o=e.afterState[t];if(o.frameCreated&&o.originalNodeId)try{const r=await figma.getNodeByIdAsync(o.originalNodeId);if(r&&r.parent&&"x"in r){const s=figma.createFrame();s.name=o.properties.name||`${r.name} Frame`,s.x=r.x,s.y=r.y,s.resize(r.width,r.height);const n=r.parent,c=n.children.indexOf(r);n.insertChild(c,s),s.appendChild(r),r.x=0,r.y=0;const f=O(B({},o),{nodeId:s.id});await this.restoreNodeState(f)}}catch(r){console.error("Failed to redo frame creation:",r),a=!1}else await this.restoreNodeState(o)||(a=!1)}return a?(this.history.currentIndex++,this.notifyHistoryChanged(),figma.notify(`↷ Redone: ${e.description}`)):figma.notify("⚠️ Failed to redo some changes"),a}canUndo(){return this.history.currentIndex>=0}canRedo(){return this.history.currentIndex<this.history.actions.length-1}getHistoryInfo(){var e,a;return{canUndo:this.canUndo(),canRedo:this.canRedo(),currentAction:this.history.currentIndex>=0?(e=this.history.actions[this.history.currentIndex])==null?void 0:e.description:null,nextAction:this.canRedo()?(a=this.history.actions[this.history.currentIndex+1])==null?void 0:a.description:null,totalActions:this.history.actions.length}}clearHistory(){this.history.actions=[],this.history.currentIndex=-1,this.notifyHistoryChanged()}notifyHistoryChanged(){figma.ui.postMessage({type:"history-changed",historyInfo:this.getHistoryInfo()})}}const m=new G;async function U(i,e,a){if(i.length>0&&e)try{let t=!1;const o=i.map(r=>m.captureNodeState(r));for(const r of i)if(await M(e,a,r)){if(a==="fill"&&"fills"in r)if(t=!0,Array.isArray(r.fills)&&r.fills.length>0){const n=[...r.fills];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.fills=n}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)];else if(a==="stroke"&&"strokes"in r)if(t=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const n=[...r.strokes];n[0]=figma.variables.setBoundVariableForPaint(n[0],"color",e),r.strokes=n}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",e)]}if(t){const r=i.map(c=>m.captureNodeState(c)),s=`Apply ${e.name} (${a})`,n={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:s,variableId:e.id,variableType:"color",action:a,beforeState:o,afterState:r};m.addAction(n),figma.notify("✅ Variable applied correctly.")}else figma.notify("🚫 Scope limitation.")}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}class q{constructor(){R(this,"pendingConfirmations",new Map)}async showConfirmation(e,a,t="Yes, proceed",o="Cancel"){const r=Date.now().toString()+Math.random().toString(36).substr(2,9);return new Promise(s=>{this.pendingConfirmations.set(r,{id:r,resolve:s}),figma.ui.postMessage({type:"show-confirmation",id:r,title:e,message:a,confirmText:t,cancelText:o})})}handleResponse(e,a){const t=this.pendingConfirmations.get(e);t&&(t.resolve(a),this.pendingConfirmations.delete(e))}}const V=new q,J=i=>{var o;const e=figma.createFrame();e.name=`${i.name} Frame`,e.x=i.x,e.y=i.y,e.resize(i.width,i.height);const a=i.parent,t=(o=a==null?void 0:a.children.indexOf(i))!=null?o:0;return a&&a.insertChild(t,e),e.appendChild(i),i.x=0,i.y=0,e.layoutMode="HORIZONTAL",e.layoutSizingHorizontal="HUG",e.layoutSizingVertical="HUG",e.paddingTop=0,e.paddingBottom=0,e.paddingLeft=0,e.paddingRight=0,e},j=i=>{let e="HORIZONTAL";if(i.children.length>=2){const a=i.children[0],t=i.children[1],o=Math.abs(a.x-t.x),r=Math.abs(a.y-t.y);e=o>r?"HORIZONTAL":"VERTICAL"}i.layoutMode=e,i.layoutSizingHorizontal="HUG",i.layoutSizingVertical="HUG"},K=async(i,e)=>{if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(e)){if(!("layoutMode"in i)){const t=e.includes("padding")?"padding":"spacing";if(!await V.showConfirmation(`Create Frame for ${t}?`,`This element needs to be wrapped in a frame to apply ${t} variables. Should I create a frame and move this element inside?`,"Yes, create frame","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires a frame. Operation cancelled.`};try{const r=J(i);return figma.currentPage.selection=[r],{success:!0,node:r,message:`✨ Created frame with Auto Layout for ${t}. Original node moved inside.`}}catch(r){return{success:!1,node:i,message:"🚨 Failed to create frame. Please manually wrap this element in a frame and enable Auto Layout."}}}const a=i;if(a.layoutMode==="NONE"){const t=e.includes("padding")?"padding":"spacing";if(!await V.showConfirmation(`Enable Auto Layout for ${t}?`,`This frame needs Auto Layout to apply ${t} variables. Should I enable Auto Layout?`,"Yes, enable Auto Layout","Cancel"))return{success:!1,node:i,message:`❌ ${t} requires Auto Layout. Operation cancelled.`};try{return j(a),{success:!0,node:a,message:`✨ Auto Layout enabled for ${t}.`}}catch(r){return{success:!1,node:i,message:`🚨 Could not enable Auto Layout. Please enable it manually for ${t}.`}}}return{success:!0,node:i,message:""}}return{success:!0,node:i,message:""}},C=(i,e,a)=>{a==="vertical"?(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e)):a==="horizontal"?(i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e)):a==="general"&&(i.setBoundVariable("paddingTop",e),i.setBoundVariable("paddingBottom",e),i.setBoundVariable("paddingLeft",e),i.setBoundVariable("paddingRight",e))},Y=(i,e)=>{"strokes"in i&&(Array.isArray(i.strokes)&&i.strokes.length>0&&i.strokes.some(t=>t.visible!==!1)||(i.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),i.setBoundVariable("strokeWeight",e),i.setBoundVariable("strokeTopWeight",e),i.setBoundVariable("strokeRightWeight",e),i.setBoundVariable("strokeBottomWeight",e),i.setBoundVariable("strokeLeftWeight",e)},Z=(i,e)=>{i.setBoundVariable("topLeftRadius",e),i.setBoundVariable("topRightRadius",e),i.setBoundVariable("bottomLeftRadius",e),i.setBoundVariable("bottomRightRadius",e)},X=(i,e)=>{const a=i.scopes;return a.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:e==="spaceBetween"&&a.includes("GAP")?{isCompatible:!0,warning:""}:e.includes("padding")&&a.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},Q=async(i,e,a)=>{var r,s,n,c,f,y,g,L;let t="";const o=[];for(const p of i){const k=m.captureNodeState(p);if(!await M(e,a,p)){t="🚫 Scope limitation.";continue}if(!("setBoundVariable"in p)){t="🚨 Node does not support variable binding.";continue}const{success:A,node:d,message:u}=await K(p,a);if(!A){t=u;continue}const S={originalNode:p,beforeState:k,finalNode:d,frameCreated:d!==p};o.push(S);const{isCompatible:W,warning:b}=X(e,a);switch(W||(t+=b),a){case"spaceBetween":d.setBoundVariable("itemSpacing",e),t=u?`✅ Spacing variable applied correctly. ${u}`:"✅ Spacing variable applied correctly.";break;case"borderRadius":Z(d,e),t="✅ Border radius variable applied correctly.";break;case"paddingVertical":if(d.type==="FRAME"){const h=d;try{C(h,e,"vertical");const l=h.boundVariables;((r=l==null?void 0:l.paddingTop)==null?void 0:r.id)===e.id||((s=l==null?void 0:l.paddingBottom)==null?void 0:s.id)===e.id?(t=u?`✅ Vertical padding variable applied correctly. ${u}`:"✅ Vertical padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(d.type==="FRAME"){const h=d;try{C(h,e,"horizontal");const l=h.boundVariables;((n=l==null?void 0:l.paddingLeft)==null?void 0:n.id)===e.id||((c=l==null?void 0:l.paddingRight)==null?void 0:c.id)===e.id?(t=u?`✅ Horizontal padding variable applied correctly. ${u}`:"✅ Horizontal padding variable applied correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(d.type==="FRAME"){const h=d;try{C(h,e,"general");const l=h.boundVariables;((f=l==null?void 0:l.paddingTop)==null?void 0:f.id)===e.id||((y=l==null?void 0:l.paddingBottom)==null?void 0:y.id)===e.id||((g=l==null?void 0:l.paddingLeft)==null?void 0:g.id)===e.id||((L=l==null?void 0:l.paddingRight)==null?void 0:L.id)===e.id?(t=u?`✅ Padding variable applied to all sides correctly. ${u}`:"✅ Padding variable applied to all sides correctly.",b&&(t+=`
💡 `+b)):t="🚨 Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(l){t="🚨 Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in d&&(Y(d,e),t="✅ Stroke variable applied with dark border.");break;default:t="🚨 Unknown action."}const w=m.captureNodeState(d);S.frameCreated&&(w.frameCreated=!0,w.originalNodeId=p.id),S.afterState=w}if(t.includes("✅")&&o.length>0){const p=o.map(d=>d.beforeState),k=o.map(d=>d.afterState),I=`Apply ${e.name} (${a})`,A={id:Date.now().toString()+Math.random().toString(36).substr(2,9),type:"apply-variable",timestamp:Date.now(),description:I,variableId:e.id,variableType:"number",action:a,beforeState:p,afterState:k};m.addAction(A)}figma.notify(t)};figma.showUI(__html__,{width:240,height:664});async function ee(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await U(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}async function te(i,e){const a=figma.currentPage.selection;if(a.length>0&&i)try{const t=await figma.variables.getVariableByIdAsync(i);if(!t){figma.notify("Error: Could not obtain the variable.");return}await Q(a,t,e)}catch(t){console.error("Error when applying the variable:",t),figma.notify("🚨 It was not possible to apply the variable.")}else figma.notify("😺 Oops! There is nothing selected.")}figma.ui.onmessage=async i=>{if(i.type==="apply-variable"){const e=i.variableId,a=i.variableType,t=i.action;a==="color"?await ee(e,t):a==="number"&&await te(e,t)}else i.type==="reload-variables"?(await F(),figma.notify("🔄 Variables reloaded.")):i.type==="confirmation-response"?V.handleResponse(i.id,i.confirmed):i.type==="undo"?await m.undo():i.type==="redo"&&await m.redo()};F();
