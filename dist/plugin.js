async function A(e){if(e.valuesByMode&&typeof e.valuesByMode=="object"){const i=Object.keys(e.valuesByMode);for(const t of i){const a=e.valuesByMode[t];if(a&&typeof a=="object"&&"type"in a&&a.type==="VARIABLE_ALIAS"&&a.id){const r=await figma.variables.getVariableByIdAsync(a.id);if(r){const s=await R(r);if(s!==void 0)return s}}else if(e.resolvedType==="COLOR"&&typeof a=="object"&&"r"in a){const r={r:a.r,g:a.g,b:a.b};return"a"in a&&(r.a=a.a),r}else if(e.resolvedType==="FLOAT"&&typeof a=="number")return a}}return null}async function R(e){return A(e)}function v(e,i,t){return new Promise((a,r)=>{const l=e.flatMap(f=>f.variables).filter(f=>f.scopes&&f.scopes.length>0);let c=0;const n=[];function g(){const f=l.slice(c,c+i);Promise.all(f.map(async d=>{const m=await A(d);n.push({alias:d.name||"No alias",id:d.id,value:m,type:d.resolvedType==="COLOR"?"color":"number",isRemote:d.remote,libraryName:e.find(h=>h.variables.includes(d)).libraryName,scopes:d.scopes||[],collectionName:e.find(h=>h.variables.includes(d)).collectionName})})).then(()=>{c+=i,c<l.length?setTimeout(g,0):(t(n),a())}).catch(r)}g()})}async function C(){try{const e=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync();for(const i of e){const t=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(i.key);for(const a of t)(a.resolvedType==="COLOR"||a.resolvedType==="FLOAT")&&await figma.variables.importVariableByKeyAsync(a.key)}figma.notify("âœ… Variables imported correctly.")}catch(e){console.error("Error when importing remote variables:",e),figma.notify("ðŸš¨ Error when importing remote variables.")}}async function V(){try{figma.ui.postMessage({type:"loading-start"}),await C();const e=await figma.variables.getLocalVariableCollectionsAsync(),i=[];for(const s of e){const l=[];for(const c of s.variableIds){const n=await figma.variables.getVariableByIdAsync(c);((n==null?void 0:n.resolvedType)==="COLOR"||(n==null?void 0:n.resolvedType)==="FLOAT")&&l.push(n)}i.push({variables:l,libraryName:"Local",collectionName:s.name})}const t=await figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync(),a=[];for(const s of t){const l=await figma.teamLibrary.getVariablesInLibraryCollectionAsync(s.key),c={variables:[],libraryName:s.libraryName,collectionName:s.name};for(const n of l)if(n.resolvedType==="COLOR"||n.resolvedType==="FLOAT"){const g=await figma.variables.importVariableByKeyAsync(n.key);c.variables.push(g)}a.push(c)}const r=[...i,...a];await v(r,50,async s=>{figma.ui.postMessage({type:"all-data",variables:s})})}catch(e){console.error("Error loading all variables :",e),figma.notify("ðŸš¨ Error loading all variables.")}finally{figma.ui.postMessage({type:"loading-end"})}}const w=async(e,i,t)=>{const{scopes:a}=e;if(a.includes("ALL_SCOPES"))return!0;if(e.resolvedType==="COLOR"){if(i==="fill"&&"fills"in t)return a.includes("ALL_FILLS")||a.includes("FRAME_FILL")&&t.type==="FRAME"||a.includes("SHAPE_FILL")&&["RECTANGLE","ELLIPSE","POLYGON","STAR"].includes(t.type)?!0:a.includes("TEXT_FILL")&&t.type==="TEXT";if(i==="stroke"&&"strokes"in t)return a.includes("STROKE_COLOR")}else if(e.resolvedType==="FLOAT"){if(i==="spaceBetween"&&t.type==="FRAME")return a.includes("GAP");if(i==="borderRadius"&&"cornerRadius"in t)return a.includes("CORNER_RADIUS");if(i.includes("padding")&&t.type==="FRAME")return t.layoutMode==="NONE"?!1:a.includes("GAP");if(i==="strokeWidth"&&"strokeWeight"in t)return a.includes("STROKE_FLOAT")}return!1};async function B(e,i,t){if(e.length>0&&i)try{let a=!1;for(const r of e)if(await w(i,t,r)){if(t==="fill"&&"fills"in r)if(a=!0,Array.isArray(r.fills)&&r.fills.length>0){const l=[...r.fills];l[0]=figma.variables.setBoundVariableForPaint(l[0],"color",i),r.fills=l}else r.fills=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",i)];else if(t==="stroke"&&"strokes"in r)if(a=!0,Array.isArray(r.strokes)&&r.strokes.length>0){const l=[...r.strokes];l[0]=figma.variables.setBoundVariableForPaint(l[0],"color",i),r.strokes=l}else r.strokes=[figma.variables.setBoundVariableForPaint({type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"},"color",i)]}a?figma.notify("âœ… Variable applied correctly."):figma.notify("ðŸš« Scope limitation.")}catch(a){console.error("Error when applying the variable:",a),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}const T=e=>{var r;const i=figma.createFrame();i.name=`${e.name} Frame`,i.x=e.x,i.y=e.y,i.resize(e.width,e.height);const t=e.parent,a=(r=t==null?void 0:t.children.indexOf(e))!=null?r:0;return t&&t.insertChild(a,i),i.appendChild(e),e.x=0,e.y=0,i.layoutMode="HORIZONTAL",i.layoutSizingHorizontal="HUG",i.layoutSizingVertical="HUG",i.paddingTop=0,i.paddingBottom=0,i.paddingLeft=0,i.paddingRight=0,i},S=e=>{let i="HORIZONTAL";if(e.children.length>=2){const t=e.children[0],a=e.children[1],r=Math.abs(t.x-a.x),s=Math.abs(t.y-a.y);i=r>s?"HORIZONTAL":"VERTICAL"}e.layoutMode=i,e.layoutSizingHorizontal="HUG",e.layoutSizingVertical="HUG"},N=async(e,i)=>{if(["spaceBetween","paddingVertical","paddingHorizontal","paddingGeneral"].includes(i)){if(!("layoutMode"in e)){const a=i.includes("padding")?"padding":"spacing";try{const r=T(e);return figma.currentPage.selection=[r],{success:!0,node:r,message:`âœ¨ Created frame with Auto Layout for ${a}. Original node moved inside.`}}catch(r){return{success:!1,node:e,message:`ðŸš¨ ${a} requires a frame. Please manually wrap this element in a frame and enable Auto Layout.`}}}const t=e;if(t.layoutMode==="NONE"){const a=i.includes("padding")?"padding":"spacing";try{return S(t),{success:!0,node:t,message:`âœ¨ Auto Layout enabled for ${a}.`}}catch(r){return{success:!1,node:e,message:`ðŸš¨ Could not enable Auto Layout. Please enable it manually for ${a}.`}}}return{success:!0,node:e,message:""}}return{success:!0,node:e,message:""}},L=(e,i,t)=>{t==="vertical"?(e.setBoundVariable("paddingTop",i),e.setBoundVariable("paddingBottom",i)):t==="horizontal"?(e.setBoundVariable("paddingLeft",i),e.setBoundVariable("paddingRight",i)):t==="general"&&(e.setBoundVariable("paddingTop",i),e.setBoundVariable("paddingBottom",i),e.setBoundVariable("paddingLeft",i),e.setBoundVariable("paddingRight",i))},E=(e,i)=>{"strokes"in e&&(Array.isArray(e.strokes)&&e.strokes.length>0&&e.strokes.some(a=>a.visible!==!1)||(e.strokes=[{type:"SOLID",color:{r:0,g:0,b:0},opacity:1,visible:!0,blendMode:"NORMAL"}])),e.setBoundVariable("strokeWeight",i),e.setBoundVariable("strokeTopWeight",i),e.setBoundVariable("strokeRightWeight",i),e.setBoundVariable("strokeBottomWeight",i),e.setBoundVariable("strokeLeftWeight",i)},F=(e,i)=>{e.setBoundVariable("topLeftRadius",i),e.setBoundVariable("topRightRadius",i),e.setBoundVariable("bottomLeftRadius",i),e.setBoundVariable("bottomRightRadius",i)},I=(e,i)=>{const t=e.scopes;return t.includes("ALL_SCOPES")?{isCompatible:!0,warning:""}:i==="spaceBetween"&&t.includes("GAP")?{isCompatible:!0,warning:""}:i.includes("padding")&&t.includes("GAP")?{isCompatible:!0,warning:"Note: This variable uses GAP scope which is primarily for spacing. If padding doesn't apply correctly, create a variable with ALL_SCOPES."}:{isCompatible:!0,warning:""}},P=async(e,i,t)=>{var r,s,l,c,n,g,f,d;let a="";for(const m of e){if(!await w(i,t,m)){a="ðŸš« Scope limitation.";continue}if(!("setBoundVariable"in m)){a="ðŸš¨ Node does not support variable binding.";continue}const{success:k,node:p,message:y}=await N(m,t);if(!k){a=y;continue}const{isCompatible:O,warning:b}=I(i,t);switch(O||(a+=b),t){case"spaceBetween":p.setBoundVariable("itemSpacing",i),a=y?`âœ… Spacing variable applied correctly. ${y}`:"âœ… Spacing variable applied correctly.";break;case"borderRadius":F(p,i),a="âœ… Border radius variable applied correctly.";break;case"paddingVertical":if(p.type==="FRAME"){const u=p;try{L(u,i,"vertical");const o=u.boundVariables;((r=o==null?void 0:o.paddingTop)==null?void 0:r.id)===i.id||((s=o==null?void 0:o.paddingBottom)==null?void 0:s.id)===i.id?(a=y?`âœ… Vertical padding variable applied correctly. ${y}`:"âœ… Vertical padding variable applied correctly.",b&&(a+=`
ðŸ’¡ `+b)):a="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingHorizontal":if(p.type==="FRAME"){const u=p;try{L(u,i,"horizontal");const o=u.boundVariables;((l=o==null?void 0:o.paddingLeft)==null?void 0:l.id)===i.id||((c=o==null?void 0:o.paddingRight)==null?void 0:c.id)===i.id?(a=y?`âœ… Horizontal padding variable applied correctly. ${y}`:"âœ… Horizontal padding variable applied correctly.",b&&(a+=`
ðŸ’¡ `+b)):a="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"paddingGeneral":if(p.type==="FRAME"){const u=p;try{L(u,i,"general");const o=u.boundVariables;((n=o==null?void 0:o.paddingTop)==null?void 0:n.id)===i.id||((g=o==null?void 0:o.paddingBottom)==null?void 0:g.id)===i.id||((f=o==null?void 0:o.paddingLeft)==null?void 0:f.id)===i.id||((d=o==null?void 0:o.paddingRight)==null?void 0:d.id)===i.id?(a=y?`âœ… Padding variable applied to all sides correctly. ${y}`:"âœ… Padding variable applied to all sides correctly.",b&&(a+=`
ðŸ’¡ `+b)):a="ðŸš¨ Failed to apply padding variable. Check variable scope - padding requires ALL_SCOPES or may not work with GAP scope."}catch(o){a="ðŸš¨ Failed to apply padding variable. Variable scope may not support padding."}}break;case"strokeWidth":"strokes"in p&&(E(p,i),a="âœ… Stroke variable applied with dark border.");break;default:a="ï¿½ï¿½ Unknown action."}}figma.notify(a)};figma.showUI(__html__,{width:240,height:664});async function M(e,i){const t=figma.currentPage.selection;if(t.length>0&&e)try{const a=await figma.variables.getVariableByIdAsync(e);if(!a){figma.notify("Error: Could not obtain the variable.");return}await B(t,a,i)}catch(a){console.error("Error when applying the variable:",a),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}async function _(e,i){const t=figma.currentPage.selection;if(t.length>0&&e)try{const a=await figma.variables.getVariableByIdAsync(e);if(!a){figma.notify("Error: Could not obtain the variable.");return}await P(t,a,i)}catch(a){console.error("Error when applying the variable:",a),figma.notify("ðŸš¨ It was not possible to apply the variable.")}else figma.notify("ðŸ˜º Oops! There is nothing selected.")}figma.ui.onmessage=async e=>{if(e.type==="apply-variable"){const i=e.variableId,t=e.variableType,a=e.action;t==="color"?await M(i,a):t==="number"&&await _(i,a)}else e.type==="reload-variables"&&(await V(),figma.notify("ðŸ”„ Variables reloaded."))};V();
